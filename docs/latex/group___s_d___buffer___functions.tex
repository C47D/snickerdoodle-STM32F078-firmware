\hypertarget{group___s_d___buffer___functions}{}\section{Buffer Functions}
\label{group___s_d___buffer___functions}\index{Buffer Functions@{Buffer Functions}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} \mbox{\hyperlink{group___s_d___buffer___functions_ga5c105cd566aea7ca95c4b9702b083cc1}{sd\+\_\+char\+\_\+buff\+\_\+init}} (struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$buff, uint32\+\_\+t size, uint8\+\_\+t $\ast$pbuff)
\begin{DoxyCompactList}\small\item\em Initialize Character Buffer. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} \mbox{\hyperlink{group___s_d___buffer___functions_ga1b12fdfcd944d5f41960209072dbda59}{sd\+\_\+doub\+\_\+buff\+\_\+init}} (struct \mbox{\hyperlink{structsd__doub__buff}{sd\+\_\+doub\+\_\+buff}} $\ast$buff, uint32\+\_\+t size, uint8\+\_\+t $\ast$$\ast$pbuff)
\begin{DoxyCompactList}\small\item\em Initialize Double Buffer. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} \mbox{\hyperlink{group___s_d___buffer___functions_gac8f2c2617479d49b27397bab04154ec9}{sd\+\_\+char\+\_\+buff\+\_\+putc}} (struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$buffer, uint8\+\_\+t data)
\begin{DoxyCompactList}\small\item\em Put Character in Buffer Write a character to the buffer. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} \mbox{\hyperlink{group___s_d___buffer___functions_gabe452c7248eb96b220e17402b476bc09}{sd\+\_\+char\+\_\+buff\+\_\+putc\+\_\+to}} (struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$buffer, uint8\+\_\+t data, uint32\+\_\+t timeout)
\begin{DoxyCompactList}\small\item\em Put Character in Buffer with Timeout Write a character to the buffer with a timeout. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} \mbox{\hyperlink{group___s_d___buffer___functions_ga4e78b9eaa502531cda91c47a1b5ea801}{sd\+\_\+char\+\_\+buff\+\_\+write}} (struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$buffer, uint8\+\_\+t $\ast$data, uint32\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Write Data to Buffer Write a specified length of characters from a data pointer to the buffer. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} \mbox{\hyperlink{group___s_d___buffer___functions_ga5b3ed30243636338cb55dcc9403534b9}{sd\+\_\+char\+\_\+buff\+\_\+read}} (struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$buff, uint8\+\_\+t $\ast$data, uint32\+\_\+t $\ast$len)
\begin{DoxyCompactList}\small\item\em Read Length of Characters from Buffer Copy a specified length of the buffer to a pointer. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} \mbox{\hyperlink{group___s_d___buffer___functions_ga8229d1047f8af8841205582a55bae473}{sd\+\_\+char\+\_\+buff\+\_\+getc}} (struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$buff, uint8\+\_\+t $\ast$data)
\begin{DoxyCompactList}\small\item\em Get Character from Buffer Get a single character from the buffer. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} \mbox{\hyperlink{group___s_d___buffer___functions_ga13cfdea81509e25f3fa884cc373fac64}{sd\+\_\+char\+\_\+buff\+\_\+getc\+\_\+to}} (struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$buff, uint8\+\_\+t $\ast$data, uint32\+\_\+t timeout)
\begin{DoxyCompactList}\small\item\em Get Character from Buffer with Timeout Get a single character from the buffer with a timeout if the buffer is locked. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} \mbox{\hyperlink{group___s_d___buffer___functions_gafc321e2e66659aca104810f576224745}{sd\+\_\+buff\+\_\+reset}} (struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$buff)
\begin{DoxyCompactList}\small\item\em Reset buffer Resets the in and out indexes of the buffer (without removing contents of the buffer) to the start of the buffer. \end{DoxyCompactList}\item 
\+\_\+\+\_\+weak void \mbox{\hyperlink{group___s_d___buffer___functions_ga62eae3c0c1cbe53dbb549106668fa24c}{sd\+\_\+char\+\_\+write\+\_\+end\+\_\+cb}} (struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$buff)
\begin{DoxyCompactList}\small\item\em Write Command End Callback User defined function executed when a write operation is completed. \end{DoxyCompactList}\item 
\+\_\+\+\_\+weak void \mbox{\hyperlink{group___s_d___buffer___functions_ga17d8b9804dc4f2cbfbf03a5c23d227e7}{sd\+\_\+char\+\_\+read\+\_\+end\+\_\+cb}} (struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$buff)
\begin{DoxyCompactList}\small\item\em Read Command End Callback User defined function executed when a read operation is completed. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group___s_d___buffer___functions_ga62fbe2b889977974789db30b055e7dac}\label{group___s_d___buffer___functions_ga62fbe2b889977974789db30b055e7dac}} 
enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} {\bfseries sd\+\_\+doub\+\_\+buff\+\_\+init} (struct \mbox{\hyperlink{structsd__doub__buff}{sd\+\_\+doub\+\_\+buff}} $\ast$buff, uint32\+\_\+t size, uint8\+\_\+t $\ast$pbuff\mbox{[}$\,$\mbox{]})
\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Function Documentation}
\mbox{\Hypertarget{group___s_d___buffer___functions_gafc321e2e66659aca104810f576224745}\label{group___s_d___buffer___functions_gafc321e2e66659aca104810f576224745}} 
\index{Buffer Functions@{Buffer Functions}!sd\+\_\+buff\+\_\+reset@{sd\+\_\+buff\+\_\+reset}}
\index{sd\+\_\+buff\+\_\+reset@{sd\+\_\+buff\+\_\+reset}!Buffer Functions@{Buffer Functions}}
\subsubsection{\texorpdfstring{sd\+\_\+buff\+\_\+reset()}{sd\_buff\_reset()}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} sd\+\_\+buff\+\_\+reset (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$}]{buff }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__buffer_8c}{Src/sd\+\_\+buffer.\+c}}$>$}



Reset buffer Resets the in and out indexes of the buffer (without removing contents of the buffer) to the start of the buffer. 


\begin{DoxyParams}{Parameters}
{\em buff} & The buffer to reset \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em S\+D\+\_\+\+B\+U\+F\+F\+\_\+\+S\+U\+C\+C\+E\+SS} & on success, error state otherwise \\
\hline
\end{DoxyRetVals}

\begin{DoxyCode}
448 \{
449     
450     \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a57815778d30aaa889a6e73dfc081e5f6}{SD\_BUFF\_SUCCESS}};
451 \}
\end{DoxyCode}
\mbox{\Hypertarget{group___s_d___buffer___functions_ga8229d1047f8af8841205582a55bae473}\label{group___s_d___buffer___functions_ga8229d1047f8af8841205582a55bae473}} 
\index{Buffer Functions@{Buffer Functions}!sd\+\_\+char\+\_\+buff\+\_\+getc@{sd\+\_\+char\+\_\+buff\+\_\+getc}}
\index{sd\+\_\+char\+\_\+buff\+\_\+getc@{sd\+\_\+char\+\_\+buff\+\_\+getc}!Buffer Functions@{Buffer Functions}}
\subsubsection{\texorpdfstring{sd\+\_\+char\+\_\+buff\+\_\+getc()}{sd\_char\_buff\_getc()}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} sd\+\_\+char\+\_\+buff\+\_\+getc (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$}]{buff,  }\item[{uint8\+\_\+t $\ast$}]{data }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__buffer_8c}{Src/sd\+\_\+buffer.\+c}}$>$}



Get Character from Buffer Get a single character from the buffer. 


\begin{DoxyParams}{Parameters}
{\em buff} & The buffer to read from \\
\hline
{\em data} & Pointer to character to write to \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em S\+D\+\_\+\+B\+U\+F\+F\+\_\+\+S\+U\+C\+C\+E\+SS} & on success, error status otherwise \\
\hline
\end{DoxyRetVals}
\begin{DoxyWarning}{Warning}
This does not destroy the contents of the buffer. The circular nature of the buffer will allow any characters to be written over, including characters that have not been read yet (buffer overflow condition).
\end{DoxyWarning}

\begin{DoxyCode}
325 \{
326                        
327     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}} == NULL)
328         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a4fbcad5e560902c4b01a8cdad1af037f}{SD\_BUFF\_NULL\_ERROR}};
329   
330     \textcolor{comment}{/* Check if the buffer was newly initialized */}
331     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state == \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba344018f8bba0021015065436cbeb6eda}{SD\_BUFF\_INITIALIZED}})
332         \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}};
333   
334     \textcolor{comment}{/* Wait until the buffer is available */}
335     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state != \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}}) 
336         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a18c0d6717027d1d8219aa76b41bf3d4c}{SD\_BUFF\_LOCKED}};
337   
338     \textcolor{comment}{/* Set the state to busy */}
339     \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba7c8ca4ffdb2641e46e6b6374fb66bb83}{SD\_BUFF\_BUSY}};
340   
341     \textcolor{comment}{/* If the buffer is at the end, wrap around */}
342     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out >= \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->size) 
343         \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out = 0;
344   
345     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->len) \{
352  *data = \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->buff[\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out++];
353     
354         \textcolor{comment}{/* Check for end of buffer and wrap around */}
355         \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out >= \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->size) 
356             \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out = 0;
357         
358         \textcolor{comment}{/* Decrement length */}
359         \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->len-- <= 0)
360             \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->len = 0;
361     \} \textcolor{keywordflow}{else} \{
362         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4ae7df9fe6e4740934def6178fe96c6f6f}{SD\_BUFF\_EMPTY}};
363     \}
364   
365     \textcolor{comment}{/* Release the buffer */}
366     \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}};
367   
368     \textcolor{comment}{/* Execute user-defined callback */}
369     \mbox{\hyperlink{group___s_d___buffer___functions_ga17d8b9804dc4f2cbfbf03a5c23d227e7}{sd\_char\_read\_end\_cb}}(\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}});
370   
371     \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a57815778d30aaa889a6e73dfc081e5f6}{SD\_BUFF\_SUCCESS}};
372 \}
\end{DoxyCode}
\mbox{\Hypertarget{group___s_d___buffer___functions_ga13cfdea81509e25f3fa884cc373fac64}\label{group___s_d___buffer___functions_ga13cfdea81509e25f3fa884cc373fac64}} 
\index{Buffer Functions@{Buffer Functions}!sd\+\_\+char\+\_\+buff\+\_\+getc\+\_\+to@{sd\+\_\+char\+\_\+buff\+\_\+getc\+\_\+to}}
\index{sd\+\_\+char\+\_\+buff\+\_\+getc\+\_\+to@{sd\+\_\+char\+\_\+buff\+\_\+getc\+\_\+to}!Buffer Functions@{Buffer Functions}}
\subsubsection{\texorpdfstring{sd\+\_\+char\+\_\+buff\+\_\+getc\+\_\+to()}{sd\_char\_buff\_getc\_to()}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} sd\+\_\+char\+\_\+buff\+\_\+getc\+\_\+to (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$}]{buff,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t}]{timeout }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__buffer_8c}{Src/sd\+\_\+buffer.\+c}}$>$}



Get Character from Buffer with Timeout Get a single character from the buffer with a timeout if the buffer is locked. 


\begin{DoxyParams}{Parameters}
{\em buff} & The buffer to read from \\
\hline
{\em data} & Pointer to character to write to \\
\hline
{\em timeout} & Timeout value to use for read \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em S\+D\+\_\+\+B\+U\+F\+F\+\_\+\+S\+U\+C\+C\+E\+SS} & on success, error status otherwise \\
\hline
\end{DoxyRetVals}
\begin{DoxyWarning}{Warning}
This does not destroy the contents of the buffer. The circular nature of the buffer will allow any characters to be written over, including characters that have not been read yet (buffer overflow condition).
\end{DoxyWarning}

\begin{DoxyCode}
389 \{
390     uint32\_t time = HAL\_GetTick();
391     
392     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}} == NULL)
393         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a4fbcad5e560902c4b01a8cdad1af037f}{SD\_BUFF\_NULL\_ERROR}};
394   
395     \textcolor{comment}{/* Check if the buffer is ready to be used */}
396     \textcolor{keywordflow}{while} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state != \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}}) \{
397         \textcolor{comment}{/* Check for timeout */}
398         \textcolor{keywordflow}{if} ((timeout == 0) || (HAL\_GetTick() - time) > timeout)
399             \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4ac09348ea1a8b94dcefdcae93b12717ba}{SD\_BUFF\_TIMEOUT}};
400     \}
401   
402     \textcolor{comment}{/* Set the state to busy */}
403     \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba7c8ca4ffdb2641e46e6b6374fb66bb83}{SD\_BUFF\_BUSY}};
404   
405     \textcolor{comment}{/* If the buffer is at the end, wrap around */}
406     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out >= \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->size) 
407         \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out = 0;
408   
409     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->len) \{
416  *data = \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->buff[\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out++];
417     
418         \textcolor{comment}{/* Check for end of buffer and wrap around */}
419         \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out >= \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->size) 
420             \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out = 0;
421         
422         \textcolor{comment}{/* Decrement length */}
423         \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->len-- <= 0)
424             \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->len = 0;
425     \} \textcolor{keywordflow}{else} \{
426         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4ae7df9fe6e4740934def6178fe96c6f6f}{SD\_BUFF\_EMPTY}};
427     \}
428   
429     \textcolor{comment}{/* Release the buffer */}
430     \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}};
431   
432     \textcolor{comment}{/* Execute user-defined callback */}
433     \mbox{\hyperlink{group___s_d___buffer___functions_ga17d8b9804dc4f2cbfbf03a5c23d227e7}{sd\_char\_read\_end\_cb}}(\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}});
434   
435     \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a57815778d30aaa889a6e73dfc081e5f6}{SD\_BUFF\_SUCCESS}};
436 \}
\end{DoxyCode}
\mbox{\Hypertarget{group___s_d___buffer___functions_ga5c105cd566aea7ca95c4b9702b083cc1}\label{group___s_d___buffer___functions_ga5c105cd566aea7ca95c4b9702b083cc1}} 
\index{Buffer Functions@{Buffer Functions}!sd\+\_\+char\+\_\+buff\+\_\+init@{sd\+\_\+char\+\_\+buff\+\_\+init}}
\index{sd\+\_\+char\+\_\+buff\+\_\+init@{sd\+\_\+char\+\_\+buff\+\_\+init}!Buffer Functions@{Buffer Functions}}
\subsubsection{\texorpdfstring{sd\+\_\+char\+\_\+buff\+\_\+init()}{sd\_char\_buff\_init()}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} sd\+\_\+char\+\_\+buff\+\_\+init (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$}]{buff,  }\item[{uint32\+\_\+t}]{size,  }\item[{uint8\+\_\+t $\ast$}]{pbuff }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__buffer_8c}{Src/sd\+\_\+buffer.\+c}}$>$}



Initialize Character Buffer. 


\begin{DoxyParams}{Parameters}
{\em buffer} & The buffer to initialize \\
\hline
{\em size} & The length of the buffer \\
\hline
{\em pbuff} & Pointer to location of character array to hold buffer data \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em S\+D\+\_\+\+B\+U\+F\+F\+\_\+\+S\+U\+C\+C\+E\+SS} & on success, error status otherwise \\
\hline
\end{DoxyRetVals}

\begin{DoxyCode}
75 \{
76     \textcolor{comment}{/* Initialize the buffer to all zeros */}
77     memset(\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}, 0, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \mbox{\hyperlink{structsd__cbuf}{sd\_cbuf}}));
78   
79     \textcolor{comment}{/* Set the default values of the buffer */}
80     \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->size = \mbox{\hyperlink{structsd__cbuf_ab2c6b258f02add8fdf4cfc7c371dd772}{size}};
81     \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->buff = pbuff;
82     
83     \textcolor{comment}{/* Buffer has been initialized */}
84     \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}};
85    
86     \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a57815778d30aaa889a6e73dfc081e5f6}{SD\_BUFF\_SUCCESS}};
87 \}
\end{DoxyCode}
\mbox{\Hypertarget{group___s_d___buffer___functions_gac8f2c2617479d49b27397bab04154ec9}\label{group___s_d___buffer___functions_gac8f2c2617479d49b27397bab04154ec9}} 
\index{Buffer Functions@{Buffer Functions}!sd\+\_\+char\+\_\+buff\+\_\+putc@{sd\+\_\+char\+\_\+buff\+\_\+putc}}
\index{sd\+\_\+char\+\_\+buff\+\_\+putc@{sd\+\_\+char\+\_\+buff\+\_\+putc}!Buffer Functions@{Buffer Functions}}
\subsubsection{\texorpdfstring{sd\+\_\+char\+\_\+buff\+\_\+putc()}{sd\_char\_buff\_putc()}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} sd\+\_\+char\+\_\+buff\+\_\+putc (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$}]{buffer,  }\item[{uint8\+\_\+t}]{data }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__buffer_8c}{Src/sd\+\_\+buffer.\+c}}$>$}



Put Character in Buffer Write a character to the buffer. 


\begin{DoxyParams}{Parameters}
{\em buffer} & The buffer to write to \\
\hline
{\em data} & The character to write \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em S\+D\+\_\+\+B\+U\+F\+F\+\_\+\+S\+U\+C\+C\+E\+SS} & on success, error status otherwise \\
\hline
\end{DoxyRetVals}

\begin{DoxyCode}
122 \{
123     \textcolor{keywordflow}{if} (buffer == NULL)
124         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a4fbcad5e560902c4b01a8cdad1af037f}{SD\_BUFF\_NULL\_ERROR}};
125     
126     \textcolor{comment}{/* Check if the buffer is ready to be used */}
127     \textcolor{keywordflow}{if} (buffer->\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} != \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}})
128         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a18c0d6717027d1d8219aa76b41bf3d4c}{SD\_BUFF\_LOCKED}};
129   
130     \textcolor{comment}{/* Set the state to busy */}
131     buffer->\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba7c8ca4ffdb2641e46e6b6374fb66bb83}{SD\_BUFF\_BUSY}};
132   
133     buffer->\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}[buffer->\mbox{\hyperlink{structsd__cbuf_a86fd6c417fa43c58339f7cde29495419}{in}}++] = data;
134   
135     \textcolor{comment}{/* Check for end of buffer and wrap around */}
136     \textcolor{keywordflow}{if} (++buffer->\mbox{\hyperlink{structsd__cbuf_a86fd6c417fa43c58339f7cde29495419}{in}} >= buffer->\mbox{\hyperlink{structsd__cbuf_ab2c6b258f02add8fdf4cfc7c371dd772}{size}}) 
137         buffer->\mbox{\hyperlink{structsd__cbuf_a86fd6c417fa43c58339f7cde29495419}{in}} = 0;
138   
139     \textcolor{comment}{/* Increase the length of the buffer */}
140     buffer->\mbox{\hyperlink{structsd__cbuf_a96bbf959016e4411c9e6b9812a8be60a}{len}}++;
141   
142     \textcolor{comment}{/* Release the buffer */}
143     buffer->\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}};
144   
145     \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a57815778d30aaa889a6e73dfc081e5f6}{SD\_BUFF\_SUCCESS}};
146 \}
\end{DoxyCode}
\mbox{\Hypertarget{group___s_d___buffer___functions_gabe452c7248eb96b220e17402b476bc09}\label{group___s_d___buffer___functions_gabe452c7248eb96b220e17402b476bc09}} 
\index{Buffer Functions@{Buffer Functions}!sd\+\_\+char\+\_\+buff\+\_\+putc\+\_\+to@{sd\+\_\+char\+\_\+buff\+\_\+putc\+\_\+to}}
\index{sd\+\_\+char\+\_\+buff\+\_\+putc\+\_\+to@{sd\+\_\+char\+\_\+buff\+\_\+putc\+\_\+to}!Buffer Functions@{Buffer Functions}}
\subsubsection{\texorpdfstring{sd\+\_\+char\+\_\+buff\+\_\+putc\+\_\+to()}{sd\_char\_buff\_putc\_to()}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} sd\+\_\+char\+\_\+buff\+\_\+putc\+\_\+to (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$}]{buffer,  }\item[{uint8\+\_\+t}]{data,  }\item[{uint32\+\_\+t}]{timeout }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__buffer_8c}{Src/sd\+\_\+buffer.\+c}}$>$}



Put Character in Buffer with Timeout Write a character to the buffer with a timeout. 


\begin{DoxyParams}{Parameters}
{\em buffer} & The buffer to write to \\
\hline
{\em data} & The character to write \\
\hline
{\em timeout} & The timeout used to write the character \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em S\+D\+\_\+\+B\+U\+F\+F\+\_\+\+S\+U\+C\+C\+E\+SS} & on success, error status otherwise \\
\hline
\end{DoxyRetVals}

\begin{DoxyCode}
161 \{
162     uint32\_t time = HAL\_GetTick();
163     
164     \textcolor{keywordflow}{if} (buffer == NULL)
165         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a4fbcad5e560902c4b01a8cdad1af037f}{SD\_BUFF\_NULL\_ERROR}};
166     
167     \textcolor{comment}{/* Check if the buffer is ready to be used */}
168     \textcolor{keywordflow}{while} (buffer->\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} != \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}}) \{
169         \textcolor{comment}{/* Check for timeout */}
170         \textcolor{keywordflow}{if} ((timeout == 0) || (HAL\_GetTick() - time) > timeout)
171             \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4ac09348ea1a8b94dcefdcae93b12717ba}{SD\_BUFF\_TIMEOUT}};
172     \}
173   
174     \textcolor{comment}{/* Set the state to busy */}
175     buffer->\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba7c8ca4ffdb2641e46e6b6374fb66bb83}{SD\_BUFF\_BUSY}};
176   
177     buffer->\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}[buffer->\mbox{\hyperlink{structsd__cbuf_a86fd6c417fa43c58339f7cde29495419}{in}}++] = data;
178   
179     \textcolor{comment}{/* Check for end of buffer and wrap around */}
180     \textcolor{keywordflow}{if} (++buffer->\mbox{\hyperlink{structsd__cbuf_a86fd6c417fa43c58339f7cde29495419}{in}} >= buffer->\mbox{\hyperlink{structsd__cbuf_ab2c6b258f02add8fdf4cfc7c371dd772}{size}}) 
181         buffer->\mbox{\hyperlink{structsd__cbuf_a86fd6c417fa43c58339f7cde29495419}{in}} = 0;
182   
183     \textcolor{comment}{/* Increase the length of the buffer */}
184     buffer->\mbox{\hyperlink{structsd__cbuf_a96bbf959016e4411c9e6b9812a8be60a}{len}}++;
185   
186     \textcolor{comment}{/* Release the buffer */}
187     buffer->\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}};
188   
189     \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a57815778d30aaa889a6e73dfc081e5f6}{SD\_BUFF\_SUCCESS}};
190 \}
\end{DoxyCode}
\mbox{\Hypertarget{group___s_d___buffer___functions_ga5b3ed30243636338cb55dcc9403534b9}\label{group___s_d___buffer___functions_ga5b3ed30243636338cb55dcc9403534b9}} 
\index{Buffer Functions@{Buffer Functions}!sd\+\_\+char\+\_\+buff\+\_\+read@{sd\+\_\+char\+\_\+buff\+\_\+read}}
\index{sd\+\_\+char\+\_\+buff\+\_\+read@{sd\+\_\+char\+\_\+buff\+\_\+read}!Buffer Functions@{Buffer Functions}}
\subsubsection{\texorpdfstring{sd\+\_\+char\+\_\+buff\+\_\+read()}{sd\_char\_buff\_read()}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} sd\+\_\+char\+\_\+buff\+\_\+read (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$}]{buff,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t $\ast$}]{len }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__buffer_8c}{Src/sd\+\_\+buffer.\+c}}$>$}



Read Length of Characters from Buffer Copy a specified length of the buffer to a pointer. 


\begin{DoxyParams}{Parameters}
{\em buff} & The buffer to read from \\
\hline
{\em data} & The data pointer to write the buffer to \\
\hline
{\em len} & The length of the buffer to read \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em S\+D\+\_\+\+B\+U\+F\+F\+\_\+\+S\+U\+C\+C\+E\+SS} & on success, error status otherwise \\
\hline
\end{DoxyRetVals}
\begin{DoxyWarning}{Warning}
This does not destroy the contents of the buffer. The circular nature of the buffer will allow any characters to be written over, including characters that have not been read yet (buffer overflow condition).
\end{DoxyWarning}

\begin{DoxyCode}
259 \{              
260     uint32\_t tmp\_len;
261                        
262     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}} == NULL)
263         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a4fbcad5e560902c4b01a8cdad1af037f}{SD\_BUFF\_NULL\_ERROR}};
264     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a96bbf959016e4411c9e6b9812a8be60a}{len}} == NULL)
265         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4addbcfa326ec75f9c48fb2b014bd8fe42}{SD\_BUFF\_ERROR}};  
266     
267     \textcolor{comment}{/* Check if the buffer was newly initialized */}
268     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state == \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba344018f8bba0021015065436cbeb6eda}{SD\_BUFF\_INITIALIZED}}) 
269         \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}};
270   
271     \textcolor{comment}{/* Wait until the buffer is available */}
272     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state != \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}})
273         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a18c0d6717027d1d8219aa76b41bf3d4c}{SD\_BUFF\_LOCKED}};
274   
275     \textcolor{comment}{/* Set the state to busy */}
276     \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba7c8ca4ffdb2641e46e6b6374fb66bb83}{SD\_BUFF\_BUSY}};
277   
278     \textcolor{comment}{/* If the buffer is at the end, wrap around */}
279     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out >= \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->len)
280         \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out = 0;
281   
282     \textcolor{keywordflow}{while} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->len) \{
289  *data++ = \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->buff[\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out++];
290     
291         \textcolor{comment}{/* Increase the length of the buffer read */}
292         tmp\_len++;
293     
294         \textcolor{comment}{/* Check for end of buffer and wrap around */}
295         \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out >= \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->size )
296             \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->out = 0;
297     
298         \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->len-- <= 0 )
299             \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->len = 0;
300     \}
301   
302     \textcolor{comment}{/* Set the length of the buffer that was read */}
303     *\mbox{\hyperlink{structsd__cbuf_a96bbf959016e4411c9e6b9812a8be60a}{len}} = tmp\_len;
304   
305     \textcolor{comment}{/* Release the buffer */}
306     \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->state = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}};
307   
308     \textcolor{comment}{/* Execute user-defined callback */}
309     \mbox{\hyperlink{group___s_d___buffer___functions_ga17d8b9804dc4f2cbfbf03a5c23d227e7}{sd\_char\_read\_end\_cb}}(\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}});
310   
311     \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a57815778d30aaa889a6e73dfc081e5f6}{SD\_BUFF\_SUCCESS}};
312 \}
\end{DoxyCode}
\mbox{\Hypertarget{group___s_d___buffer___functions_ga4e78b9eaa502531cda91c47a1b5ea801}\label{group___s_d___buffer___functions_ga4e78b9eaa502531cda91c47a1b5ea801}} 
\index{Buffer Functions@{Buffer Functions}!sd\+\_\+char\+\_\+buff\+\_\+write@{sd\+\_\+char\+\_\+buff\+\_\+write}}
\index{sd\+\_\+char\+\_\+buff\+\_\+write@{sd\+\_\+char\+\_\+buff\+\_\+write}!Buffer Functions@{Buffer Functions}}
\subsubsection{\texorpdfstring{sd\+\_\+char\+\_\+buff\+\_\+write()}{sd\_char\_buff\_write()}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} sd\+\_\+char\+\_\+buff\+\_\+write (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$}]{buffer,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t}]{len }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__buffer_8c}{Src/sd\+\_\+buffer.\+c}}$>$}



Write Data to Buffer Write a specified length of characters from a data pointer to the buffer. 


\begin{DoxyParams}{Parameters}
{\em buffer} & The buffer to write to \\
\hline
{\em data} & The data pointer to data to write to buffer \\
\hline
{\em len} & The length of the buffer to write \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em S\+D\+\_\+\+B\+U\+F\+F\+\_\+\+S\+U\+C\+C\+E\+SS} & on success, error status otherwise \\
\hline
\end{DoxyRetVals}

\begin{DoxyCode}
206 \{
207     \textcolor{keywordflow}{if} (buffer == NULL)
208         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a4fbcad5e560902c4b01a8cdad1af037f}{SD\_BUFF\_NULL\_ERROR}};
209     \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_a96bbf959016e4411c9e6b9812a8be60a}{len}} == 0)
210         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4addbcfa326ec75f9c48fb2b014bd8fe42}{SD\_BUFF\_ERROR}};
211   
212     \textcolor{comment}{/* Check if the buffer was newly initialized */}
213     \textcolor{keywordflow}{if} (buffer->\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} == \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba344018f8bba0021015065436cbeb6eda}{SD\_BUFF\_INITIALIZED}} ) 
214         buffer->\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}};
215   
216     \textcolor{keywordflow}{if} (buffer->\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} != \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}})
217         \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a18c0d6717027d1d8219aa76b41bf3d4c}{SD\_BUFF\_LOCKED}};
218 
219     \textcolor{comment}{/* Set the state to busy */}
220     buffer->\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba7c8ca4ffdb2641e46e6b6374fb66bb83}{SD\_BUFF\_BUSY}};
221   
222     \textcolor{comment}{/* If the buffer is at the end, wrap around */}
223     \textcolor{keywordflow}{if} (buffer->\mbox{\hyperlink{structsd__cbuf_a86fd6c417fa43c58339f7cde29495419}{in}} >= buffer->\mbox{\hyperlink{structsd__cbuf_ab2c6b258f02add8fdf4cfc7c371dd772}{size}})
224         buffer->\mbox{\hyperlink{structsd__cbuf_a86fd6c417fa43c58339f7cde29495419}{in}} = 0; 
225   
226     \textcolor{keywordflow}{while} (\mbox{\hyperlink{structsd__cbuf_a96bbf959016e4411c9e6b9812a8be60a}{len}}--) \{
227         \textcolor{comment}{/* Add the data to the buffer */}
228         buffer->\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}[buffer->\mbox{\hyperlink{structsd__cbuf_a86fd6c417fa43c58339f7cde29495419}{in}}] = *data++;
229     
230         \textcolor{comment}{/* Check for end of buffer and wrap around */}
231         \textcolor{keywordflow}{if} (++buffer->\mbox{\hyperlink{structsd__cbuf_a86fd6c417fa43c58339f7cde29495419}{in}} >= buffer->\mbox{\hyperlink{structsd__cbuf_ab2c6b258f02add8fdf4cfc7c371dd772}{size}} ) buffer->\mbox{\hyperlink{structsd__cbuf_a86fd6c417fa43c58339f7cde29495419}{in}} = 0;
232     
233         \textcolor{comment}{/* Increase count (length) of buffer */}
234         buffer->\mbox{\hyperlink{structsd__cbuf_a96bbf959016e4411c9e6b9812a8be60a}{len}}++;
235     \}
236   
237     \textcolor{comment}{/* Release the buffer */}
238     buffer->\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} = \mbox{\hyperlink{group___s_d___buffer___types_gga52f14e9c7b7d9ba092e1cd615559012ba99d36bbc57255841b60f77f1a0059c7c}{SD\_BUFF\_READY}};
239   
240     \textcolor{comment}{/* Execute user-defined callback */}
241     \mbox{\hyperlink{group___s_d___buffer___functions_ga62eae3c0c1cbe53dbb549106668fa24c}{sd\_char\_write\_end\_cb}}(buffer);
242   
243     \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a57815778d30aaa889a6e73dfc081e5f6}{SD\_BUFF\_SUCCESS}};
244 \}
\end{DoxyCode}
\mbox{\Hypertarget{group___s_d___buffer___functions_ga17d8b9804dc4f2cbfbf03a5c23d227e7}\label{group___s_d___buffer___functions_ga17d8b9804dc4f2cbfbf03a5c23d227e7}} 
\index{Buffer Functions@{Buffer Functions}!sd\+\_\+char\+\_\+read\+\_\+end\+\_\+cb@{sd\+\_\+char\+\_\+read\+\_\+end\+\_\+cb}}
\index{sd\+\_\+char\+\_\+read\+\_\+end\+\_\+cb@{sd\+\_\+char\+\_\+read\+\_\+end\+\_\+cb}!Buffer Functions@{Buffer Functions}}
\subsubsection{\texorpdfstring{sd\+\_\+char\+\_\+read\+\_\+end\+\_\+cb()}{sd\_char\_read\_end\_cb()}}
{\footnotesize\ttfamily void sd\+\_\+char\+\_\+read\+\_\+end\+\_\+cb (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$}]{buff }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__buffer_8c}{Src/sd\+\_\+buffer.\+c}}$>$}



Read Command End Callback User defined function executed when a read operation is completed. 

\begin{DoxyNote}{Note}
This function should not be modified, when the callback is needed, the sd\+\_\+char\+\_\+read\+\_\+end\+\_\+cb can be implemented in the user file.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em buff} & The buffer that was read \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em none} & \\
\hline
\end{DoxyRetVals}

\begin{DoxyCode}
485 \{
486 
487 \}
\end{DoxyCode}
\mbox{\Hypertarget{group___s_d___buffer___functions_ga62eae3c0c1cbe53dbb549106668fa24c}\label{group___s_d___buffer___functions_ga62eae3c0c1cbe53dbb549106668fa24c}} 
\index{Buffer Functions@{Buffer Functions}!sd\+\_\+char\+\_\+write\+\_\+end\+\_\+cb@{sd\+\_\+char\+\_\+write\+\_\+end\+\_\+cb}}
\index{sd\+\_\+char\+\_\+write\+\_\+end\+\_\+cb@{sd\+\_\+char\+\_\+write\+\_\+end\+\_\+cb}!Buffer Functions@{Buffer Functions}}
\subsubsection{\texorpdfstring{sd\+\_\+char\+\_\+write\+\_\+end\+\_\+cb()}{sd\_char\_write\_end\_cb()}}
{\footnotesize\ttfamily void sd\+\_\+char\+\_\+write\+\_\+end\+\_\+cb (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__cbuf}{sd\+\_\+cbuf}} $\ast$}]{buff }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__buffer_8c}{Src/sd\+\_\+buffer.\+c}}$>$}



Write Command End Callback User defined function executed when a write operation is completed. 

\begin{DoxyNote}{Note}
This function should not be modified, when the callback is needed, the sd\+\_\+char\+\_\+write\+\_\+end\+\_\+cb can be implemented in the user file.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em buff} & The buffer that was written \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em None} & \\
\hline
\end{DoxyRetVals}

\begin{DoxyCode}
467 \{
468     
469 \}
\end{DoxyCode}
\mbox{\Hypertarget{group___s_d___buffer___functions_ga1b12fdfcd944d5f41960209072dbda59}\label{group___s_d___buffer___functions_ga1b12fdfcd944d5f41960209072dbda59}} 
\index{Buffer Functions@{Buffer Functions}!sd\+\_\+doub\+\_\+buff\+\_\+init@{sd\+\_\+doub\+\_\+buff\+\_\+init}}
\index{sd\+\_\+doub\+\_\+buff\+\_\+init@{sd\+\_\+doub\+\_\+buff\+\_\+init}!Buffer Functions@{Buffer Functions}}
\subsubsection{\texorpdfstring{sd\+\_\+doub\+\_\+buff\+\_\+init()}{sd\_doub\_buff\_init()}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group___s_d___buffer___types_ga012d8a07d989f00e3f9c4a2f62743de4}{sd\+\_\+buff\+\_\+err}} sd\+\_\+doub\+\_\+buff\+\_\+init (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__doub__buff}{sd\+\_\+doub\+\_\+buff}} $\ast$}]{buff,  }\item[{uint32\+\_\+t}]{size,  }\item[{uint8\+\_\+t $\ast$$\ast$}]{pbuff }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__buffer_8c}{Src/sd\+\_\+buffer.\+c}}$>$}



Initialize Double Buffer. 


\begin{DoxyParams}{Parameters}
{\em buff} & The buffer to initialize \\
\hline
{\em size} & Length of the buffer \\
\hline
{\em pbuff} & Pointer to buffer array \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em S\+D\+\_\+\+B\+U\+F\+F\+\_\+\+S\+U\+C\+C\+E\+SS} & on success, error status otherwise \\
\hline
\end{DoxyRetVals}

\begin{DoxyCode}
102 \{
103     memset(\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}, 0, \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \mbox{\hyperlink{structsd__doub__buff}{sd\_doub\_buff}}));
104     
105     \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->size = \mbox{\hyperlink{structsd__cbuf_ab2c6b258f02add8fdf4cfc7c371dd772}{size}};
106     \mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}->buff = pbuff;
107 
108     \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___buffer___types_gga012d8a07d989f00e3f9c4a2f62743de4a57815778d30aaa889a6e73dfc081e5f6}{SD\_BUFF\_SUCCESS}};
109 \}
\end{DoxyCode}
