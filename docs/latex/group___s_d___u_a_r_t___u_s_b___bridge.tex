\hypertarget{group___s_d___u_a_r_t___u_s_b___bridge}{}\section{U\+A\+RT to U\+SB Bridge}
\label{group___s_d___u_a_r_t___u_s_b___bridge}\index{U\+A\+R\+T to U\+S\+B Bridge@{U\+A\+R\+T to U\+S\+B Bridge}}


snickerdoodle U\+A\+RT to U\+SB bridge functions  


\subsection*{Modules}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group___s_d___u_a_r_t___u_s_b___bridge___types}{U\+A\+R\+T U\+S\+B Bridge Types}}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{group___s_d___u_a_r_t___u_s_b___bridge___types_ga7e4773a8cce69fafe541cad55985f146}{sd\+\_\+uart\+\_\+usb\+\_\+err}} \mbox{\hyperlink{group___s_d___u_a_r_t___u_s_b___bridge_gaa03f4625c66a0fe3be62a6aead8ac2ba}{sd\+\_\+uart\+\_\+usb\+\_\+bridge\+\_\+init}} (void)
\begin{DoxyCompactList}\small\item\em U\+A\+RT to U\+SB Bridge Initialization Initialize U\+A\+RT device structure, U\+A\+RT to U\+SB bridge buffer and set the U\+A\+RT device to use the (previously initialized) U\+A\+RT peripheral and newly initialized buffer. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group___s_d___u_a_r_t___u_s_b___bridge___types_ga7e4773a8cce69fafe541cad55985f146}{sd\+\_\+uart\+\_\+usb\+\_\+err}} \mbox{\hyperlink{group___s_d___u_a_r_t___u_s_b___bridge_ga7277fee3051720471dd68980c4928cbc}{sd\+\_\+uart\+\_\+usb\+\_\+transmit}} (struct \mbox{\hyperlink{structsd__uart__dev}{sd\+\_\+uart\+\_\+dev}} $\ast$dev)
\begin{DoxyCompactList}\small\item\em U\+A\+RT to U\+SB Bridge Transmission Transmit the buffer that has been recieved on the bridged U\+A\+RT over U\+SB communications device. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
snickerdoodle U\+A\+RT to U\+SB bridge functions 



\subsection{Function Documentation}
\mbox{\Hypertarget{group___s_d___u_a_r_t___u_s_b___bridge_gaa03f4625c66a0fe3be62a6aead8ac2ba}\label{group___s_d___u_a_r_t___u_s_b___bridge_gaa03f4625c66a0fe3be62a6aead8ac2ba}} 
\index{U\+A\+R\+T to U\+S\+B Bridge@{U\+A\+R\+T to U\+S\+B Bridge}!sd\+\_\+uart\+\_\+usb\+\_\+bridge\+\_\+init@{sd\+\_\+uart\+\_\+usb\+\_\+bridge\+\_\+init}}
\index{sd\+\_\+uart\+\_\+usb\+\_\+bridge\+\_\+init@{sd\+\_\+uart\+\_\+usb\+\_\+bridge\+\_\+init}!U\+A\+R\+T to U\+S\+B Bridge@{U\+A\+R\+T to U\+S\+B Bridge}}
\subsubsection{\texorpdfstring{sd\+\_\+uart\+\_\+usb\+\_\+bridge\+\_\+init()}{sd\_uart\_usb\_bridge\_init()}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group___s_d___u_a_r_t___u_s_b___bridge___types_ga7e4773a8cce69fafe541cad55985f146}{sd\+\_\+uart\+\_\+usb\+\_\+err}} sd\+\_\+uart\+\_\+usb\+\_\+bridge\+\_\+init (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__platform_8c}{Src/sd\+\_\+platform.\+c}}$>$}



U\+A\+RT to U\+SB Bridge Initialization Initialize U\+A\+RT device structure, U\+A\+RT to U\+SB bridge buffer and set the U\+A\+RT device to use the (previously initialized) U\+A\+RT peripheral and newly initialized buffer. 


\begin{DoxyRetVals}{Return values}
{\em State} & of U\+A\+RT U\+SB bridge after initialization \\
\hline
\end{DoxyRetVals}

\begin{DoxyCode}
351 \{
352     \textcolor{comment}{/* Initialize the UART device(s) */}
353 \textcolor{comment}{//  if (sd\_uart\_dev\_init(&uart1\_dev) != SD\_UART\_SUCCESS)}
354 \textcolor{comment}{//      return SD\_UART\_USB\_ERROR;}
355 \textcolor{comment}{//  }
356 \textcolor{comment}{//  if (sd\_uart\_dev\_init(&uart2\_dev) != SD\_UART\_SUCCESS)}
357 \textcolor{comment}{//      return SD\_UART\_USB\_ERROR;}
358 \textcolor{comment}{//  }
359 \textcolor{comment}{//  /* Initialize the UART <--> USB Buffer */}
360 \textcolor{comment}{//  if (sd\_char\_buff\_init(&uart1\_rx\_cbuff, }
361 \textcolor{comment}{//                CONS\_UART\_RX\_BUFF\_SIZE, }
362 \textcolor{comment}{//                uart1\_rx\_buff) != SD\_BUFF\_SUCCESS)}
363 \textcolor{comment}{//      return SD\_UART\_USB\_ERROR;}
364 \textcolor{comment}{//  }
365 \textcolor{comment}{//  if (sd\_char\_buff\_init(&uart2\_rx\_cbuff, }
366 \textcolor{comment}{//                CONS\_UART\_RX\_BUFF\_SIZE,}
367 \textcolor{comment}{//                uart2\_rx\_buff) != SD\_BUFF\_SUCCESS)}
368 \textcolor{comment}{//      return SD\_UART\_USB\_ERROR;}
369 \textcolor{comment}{//  }
370 \textcolor{comment}{//  /* Set the UART device with the peripheral and buffer*/}
371 \textcolor{comment}{//  if (sd\_uart\_rx\_init(&uart1\_dev, &huart1, &uart1\_rx\_cbuff) != SD\_BUFF\_SUCCESS)}
372 \textcolor{comment}{//      return SD\_UART\_USB\_ERROR;}
373 \textcolor{comment}{//  }
374 \textcolor{comment}{//  if (sd\_uart\_rx\_init(&uart2\_dev, &huart2, &uart2\_rx\_cbuff) != SD\_BUFF\_SUCCESS)}
375 \textcolor{comment}{//      return SD\_UART\_USB\_ERROR;}
376 
377     \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___u_a_r_t___u_s_b___bridge___types_gga7e4773a8cce69fafe541cad55985f146a5f1ee74f25f6a6f1aa6b771dc91abe11}{SD\_UART\_USB\_SUCCESS}};
378 \}
\end{DoxyCode}
\mbox{\Hypertarget{group___s_d___u_a_r_t___u_s_b___bridge_ga7277fee3051720471dd68980c4928cbc}\label{group___s_d___u_a_r_t___u_s_b___bridge_ga7277fee3051720471dd68980c4928cbc}} 
\index{U\+A\+R\+T to U\+S\+B Bridge@{U\+A\+R\+T to U\+S\+B Bridge}!sd\+\_\+uart\+\_\+usb\+\_\+transmit@{sd\+\_\+uart\+\_\+usb\+\_\+transmit}}
\index{sd\+\_\+uart\+\_\+usb\+\_\+transmit@{sd\+\_\+uart\+\_\+usb\+\_\+transmit}!U\+A\+R\+T to U\+S\+B Bridge@{U\+A\+R\+T to U\+S\+B Bridge}}
\subsubsection{\texorpdfstring{sd\+\_\+uart\+\_\+usb\+\_\+transmit()}{sd\_uart\_usb\_transmit()}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group___s_d___u_a_r_t___u_s_b___bridge___types_ga7e4773a8cce69fafe541cad55985f146}{sd\+\_\+uart\+\_\+usb\+\_\+err}} sd\+\_\+uart\+\_\+usb\+\_\+transmit (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structsd__uart__dev}{sd\+\_\+uart\+\_\+dev}} $\ast$}]{dev }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



{\ttfamily \#include $<$\mbox{\hyperlink{sd__platform_8c}{Src/sd\+\_\+platform.\+c}}$>$}



U\+A\+RT to U\+SB Bridge Transmission Transmit the buffer that has been recieved on the bridged U\+A\+RT over U\+SB communications device. 


\begin{DoxyParams}{Parameters}
{\em uart\+\_\+dev} & U\+A\+RT device structure that is bridged \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em S\+D\+\_\+\+U\+A\+R\+T\+\_\+\+U\+S\+B\+\_\+\+S\+U\+C\+C\+E\+SS} & on success, error state otherwise \\
\hline
\end{DoxyRetVals}

\begin{DoxyCode}
390 \{
391     \textcolor{keyword}{struct }\mbox{\hyperlink{structsd__cbuf}{sd\_cbuf}} *rxbuff = dev->\mbox{\hyperlink{structsd__uart__dev_a2bc17c33f4234299b83ba5d98edd5887}{rx\_buff}};
392     \textcolor{keyword}{static} uint8\_t txbuff[\mbox{\hyperlink{group___s_d___platform___defines_gaf42bf8bfc63a6cca851012eeb8e25b52}{CONS\_UART\_RX\_BUFF\_SIZE}}];
393     \textcolor{keyword}{static} uint32\_t idx;
394     uint8\_t \mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}};
395 
396     \textcolor{keywordflow}{while} (rxbuff->\mbox{\hyperlink{structsd__cbuf_a96bbf959016e4411c9e6b9812a8be60a}{len}} && (idx < \mbox{\hyperlink{group___s_d___platform___defines_gaf42bf8bfc63a6cca851012eeb8e25b52}{CONS\_UART\_RX\_BUFF\_SIZE}})) \{
397         \textcolor{comment}{/* Check for the end of the buffer and wrap */}
398         \textcolor{keywordflow}{if} (rxbuff->\mbox{\hyperlink{structsd__cbuf_ab27775f0ed2b042b439a7431fbe311eb}{out}} >= rxbuff->\mbox{\hyperlink{structsd__cbuf_ab2c6b258f02add8fdf4cfc7c371dd772}{size}})
399             rxbuff->\mbox{\hyperlink{structsd__cbuf_ab27775f0ed2b042b439a7431fbe311eb}{out}} = 0;
400     
401         \textcolor{comment}{/* Put the character in the secondary buffer */}
402         txbuff[idx++] = rxbuff->\mbox{\hyperlink{structsd__cbuf_a8b212742c92a124f2eb4a244acc19f7c}{buff}}[rxbuff->\mbox{\hyperlink{structsd__cbuf_ab27775f0ed2b042b439a7431fbe311eb}{out}}++];
403     
404         \textcolor{comment}{/* Check for the end of the buffer and wrap */}
405         \textcolor{keywordflow}{if} (rxbuff->\mbox{\hyperlink{structsd__cbuf_ab27775f0ed2b042b439a7431fbe311eb}{out}} >= rxbuff->\mbox{\hyperlink{structsd__cbuf_ab2c6b258f02add8fdf4cfc7c371dd772}{size}})
406             rxbuff->\mbox{\hyperlink{structsd__cbuf_ab27775f0ed2b042b439a7431fbe311eb}{out}} = 0;
407     
408         \textcolor{keywordflow}{if} (--rxbuff->\mbox{\hyperlink{structsd__cbuf_a96bbf959016e4411c9e6b9812a8be60a}{len}} <= 0)
409             rxbuff->\mbox{\hyperlink{structsd__cbuf_a96bbf959016e4411c9e6b9812a8be60a}{len}} = 0;
410     
411         \textcolor{comment}{/* Check if the UART interrupt has been triggered and end this loop */}
412         \textcolor{keywordflow}{if} ((\_\_HAL\_UART\_GET\_IT(dev->\mbox{\hyperlink{structsd__uart__dev_a31b2a452cffe839ac4a3bf86eddc16b0}{uart}}, UART\_IT\_RXNE) != RESET) && 
413             (\_\_HAL\_UART\_GET\_IT\_SOURCE(dev->\mbox{\hyperlink{structsd__uart__dev_a31b2a452cffe839ac4a3bf86eddc16b0}{uart}}, UART\_IT\_RXNE) != RESET))
414             \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___u_a_r_t___u_s_b___bridge___types_gga7e4773a8cce69fafe541cad55985f146a5f1ee74f25f6a6f1aa6b771dc91abe11}{SD\_UART\_USB\_SUCCESS}};  \textcolor{comment}{/* End the loop here so that the UART can
       operate */}
415     \}
416 
417     \textcolor{comment}{/* Transmit if there is anything to transmit */}
418     \textcolor{keywordflow}{if} (idx) \{
419         \mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} = sd\_cdc\_get\_state();
420         
421         \textcolor{keywordflow}{if} (\mbox{\hyperlink{structsd__cbuf_aa88ff4ca3b7aaba9e9aaa27fd9ea94a9}{state}} == USBD\_STATE\_CONFIGURED) \{
422             \mbox{\hyperlink{group___s_d___u_s_b___c_d_c___i_f___functions_gabd3573e5083061a52edc3dcd98e6f827}{sd\_cdc\_transmit}}(txbuff, idx);
423             idx = 0;    \textcolor{comment}{/* Reset the index once we've transmitted */}
424         \}
425     \}
426 
427     \textcolor{keywordflow}{return} \mbox{\hyperlink{group___s_d___u_a_r_t___u_s_b___bridge___types_gga7e4773a8cce69fafe541cad55985f146a5f1ee74f25f6a6f1aa6b771dc91abe11}{SD\_UART\_USB\_SUCCESS}};
428 \}
\end{DoxyCode}
